## 数据结构的堆、栈以及队列

1. 堆

   堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质

   - 堆中某个节点的值总是不大于或不小于其父节点的值。
   - 堆中某个节点的值总是不大于或不小于其父节点的值。

   将根节点最大的堆叫做最大堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆。

2. 栈

   一种先进后出的线性表，主要有出栈（pop）和入栈（push）操作。C++库自带stack类。

3. 队列

   一种先进先出的线性表。C++库自带queue类。

## 操作系统中的堆栈空间分配

前面说了数据结构的概念，就是为了和操纵系统的堆栈空间区分开来。

1. 内存分配

   栈：由操作系统自动分配释放 ，存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈。

   堆：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式类似于链表。

2. 效率比较

   栈：使用的是一级缓存，他们通常都是被调用时处于存储空间中，调用完毕立即释放。但程序员是无法控制的。

   堆：则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些，而且容易产生内存碎片，不过用起来最方便。

3. 申请响应

   栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。

   堆：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻 找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆节点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

4. 申请限制

   栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是一个编译时就确定的常数，如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。

   堆：堆是向高地址拓展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储空闲内存的，自然是不连续的。而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。因此堆获得的空间比较大，也比较灵活。

5. 申请的时刻

   堆在运行是申请。

   栈在编译时确定。

## C++ 的堆栈知识

C++编译的程序占用的内存分为以下几个部分

1. 栈区（stack）

   有编译器自动分配释放，存放函数的参数名，局部变量的名字等。其操作方式类似于数据结构中的栈。

2. 堆区（heap）

    由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。C++利用new运算符申请。

3. 静态区

   全局变量和局部静态变量的存储是放在一块的，程序结束后由系统释放。静态变量若没有初始化，编译器会自动初始化为0。

4. 文字常量区

   常量字符串就是放在这里的，程序结束后由系统释放 。

5. 程序代码区

   存放函数体的二进制代码。

下面我们看这样一段程序

```c++
#include <iostream>

struct Vector3
{
	float x, y, z;
	Vector3() 
		: x(10), y(11), z(12){}
};

int main()
{
    /*
    以下变量都是栈自动分配空间，在window10系统中，最先定义的value
    在内存的高位，栈快的原因是因为它只需要移动栈指针来分配和释放空间，
    栈的释放是有范围的，这个范围一般是由{}界定，跳出一个{}，则清空一段栈
	*/
	int value = 5;  
	int array[5];
	array[0] = 1;
	array[1] = 2;
	array[2] = 3;
	array[3] = 4;
	array[4] = 5;
	Vector3 vector;

    /*
    以下是堆分配空间，new需要向操作系统申请空间，操作系统会从空闲空间链表中找一个比申请
    大的节点空间给程序使用，因此下面几个变量的存储空间是不联系的，关键字new其实是一个函数
    通过该代码的汇编语言你可以看到，new都是调用一个特定地址的函数。
    */
	int* hvalue = new int;  
	*hvalue = 5;
	int* harray = new int[5];
	harray[0] = 1; 
	harray[1] = 2;
	harray[2] = 3;
	harray[3] = 4;
	harray[4] = 5;
	Vector3* hvector = new Vector3();

    //delete关键字也是调用一段函数，释放堆空间
	delete hvalue;
	delete[] harray;
	delete hvector;
	
	std::cin.get();
	return 0;
}
```

这里需要强调的是，在栈中的操作更快，因为它们是连续一块内存，所以当读入CPU的时候整行整行读进去的，但是如果大量使用堆，将会有很多缓存miss，这这也是局部性原理的思想。

还有通过观察汇编指令，你会发现定义一个变量，只需要一条CPU指令，直接将5赋值到内存空间，但是使用new的话需要调用new函数，申请空间等操作，远远没有栈的速度快。

结论就是，除非你的数据生存时间需要比你的范围生存时间长，或者你需要存储大量数据才用堆，因为堆空间的申请是很耗时间的。 	 

当然内存分配数域计算机系统的知识，说明对底层可以很大地优化你的代码。

## 参考文献	

- [什么是堆栈](https://baike.baidu.com/item/%E5%A0%86%E6%A0%88/1682032?fr=aladdin)
- [Stack vs Heap Memory in C++](https://www.youtube.com/watch?v=wJ1L2nSIV1s&t=947s)