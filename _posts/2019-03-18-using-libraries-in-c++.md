# using libraries in c++ (Static linking)

C++ 程序从代码到可执行文件，需要经过以下几个步骤

1. 预处理。

   这时候其实就是将预处理命令进行简单的语义替换，例如 

   ```c++
   #include <iostream>
   ```

   预处理阶段会将 `iostream` 文件里的文本全部替换到这个语句的位置，因此头文件就是用来声明函数或者写全局变量的。

2. 编译

   `.cpp` 文件预处理后变成预处理文本 `.s` 文件，接着就是编译过程了，编译过程就是将高级语言翻译成汇编语言，通过编译器完成，经过优化的编译后的代码可能和你的逻辑完全不一样，但是输入和输出都是一样的。

3. 汇编

   就是将汇编指令翻译为机器指令，这个实现不难，简单的替换。

4. 链接

   每个 `.cpp` 文件都是一个编译单元，最后经过汇编会生成多个二进制文件，链接就是将这些二进制文件和一些库文件链接到一些生成可执行文件。

之所以要说 C++ 代码的执行过程，是因为接下来要讲到一个很重要的概念，那就是静态库。

为了避免造重复造破轮子，一些专业的程序员会将一些领域的常用函数做一个总结，打包放到一起供我们这些半吊子程序员使用，让我们写出来的程序也能让寂寞也追不上。这些函数的打包，我们称其为函数库，函数库分两种，一种是静态库，一种是动态库。它们之间的区别就是静态库在链接的时候用到，动态库在程序运行的时候用到，我们现在只讲静态库，以 [glfw 库](https://www.glfw.org) 为例。

直接从网站上下载源代码后你会发现，文件里面主要有两类文件夹。

1. include 文件夹

   这个文件夹里有所有函数声明的头文件，如果要使用其中的函数，只需包含进来即可。

2. lib 文件夹

   仅仅有声明不够，当到了链接的时候，我们需要静态库里面的实现，在这个文件夹里你会看见有 `.lib` 后缀的文件，其实这个文件是所有函数进行编译后的 `.o` 文件的打包，这也就可以解释为什么静态库会在链接的时候起作用了。

本人是使用 VS 2017 来编写 C++ 的，因此要使用的时候直接在项目属性里面进行设置相应的路径就可以使用引入的静态库了。`glfw` 是编写 OpenGL 程序的时候需要用到的库。

使用引入库的时候，可能会报错，有如下几个原因。

1. 编译出错

   那是因为你没有将真正的头文件引入，自然就找不到你的函数声明，引入头文件有两种语法，当头文件不是项目自带的时候用 `<>`  例如平台自带的库 iostream ，当头文件是项目自带的时候用 `""` , 例如 glfw 头文件；

2. 链接出错

   头文件引入成功，但是你的 `.lib` 包的路径没有设置好，导致链接的时候出错。

